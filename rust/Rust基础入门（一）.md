# Rust 基础入门

## 变量绑定与解构

### 变量命名
遵循 [Rust 命名规范](https://course.rs/practice/naming.html)，关键字查看[附录A](https://course.rs/appendix/keywords.html)。

### 变量绑定

```rust
let a = "hello world" 
```

明确所有权概念，所以称之为"变量绑定"。

### 变量可变性
Rust 的变量在默认情况下是**不可变的**，使用`mut`关键字让变量可变。
```rust
// 错误
let x = 5;
x = 5;
error[E0384]: cannot assign twice to immutable variable `x`

// 正确
let mut x = 5;
x = 5;
```

### 使用下划线开头忽略未使用的变量

```rust 
 let _x = 5;
```

### 变量解构

```rust
let (a, mut b): (bool, bool) = (true, false);

let (a, b, c, d, e);
(a, b) = (1, 2);
[c, .., d, _] = [1, 2, 3, 4, 5];
Struct { e, .. } = Struct { e: 5 };

```
**+=** 的赋值语句还不支持解构式赋值。

### 变量与变量之间的差异

- 常量不能使用`mut`，常量始终不可变。
- 常量使用`canst` 关键字。
```rust 
const MAX_POINTS: u32 = 100_000;
```

### 变量遮蔽（shadowing）

允许声明相同的变量名，后者遮蔽前者。

```rust 
fn main() {
   let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
   let x = x + 1;

   {
      // 在当前的花括号作用域内，对之前的x进行遮蔽
      let x = x * 2;
   }
}
```

变量遮蔽**涉及一次内存对象的再分配**，而`mut`只是修改同一内存地址上的值。

## 基本类型

### 基本类型

- 数值类型：有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数。
- 字符串：字符串字面量和字符串切片 &str。
- 布尔类型：`true` 和 `false`。
- 字符类型：表示单个 Unicode 字符，存储为 4 个字节。
- 单元类型：即 `()` ，其唯一的值也是 `()`。

### 类型推导与标注

Rust是一门**静态语言**。可以根据上下文推导变量类型，但某些情况下仍然需要手动标注。

### 数值类型

#### 整数类型

Rust 整型默认使用 `i32`，即：
```rust
let i = 10; // 默认32位
```

`i`代表有符号整数，例如`i32`：32位有符号整数。
`u`代表无符号整数，例如`u32`：32位无符号整数。

- 类型定义的形式统一为：**有无符号 + 类型大小(位数)**。
- 每个有符号类型规定的数字范围是![alt text](./assets/image-1.png){width=200px height=25px}，例`i8`可存储范围：**-128 ~ 127**。
- `isize`，`usize`取决运行时CPU，若CPU是32位则这个类型是`i32`。
- 整形字面量
  - 十进制：`98_222`
  - 十六进制：`0xff`
  - 八进制：`0o77`
  - 二进制：`0b1111_0000`
  - 字节 (仅限于 u8)：`b'A'`

##### 整数溢出


#### 浮点类型
两种基本类型：`f32`和`f64`，默认是`f64`。浮点数根据 IEEE-754 标准实现，存在**浮点数陷阱**。
`f32`单精度，`f64`双精度。

##### 浮点数陷阱

##### NaN
`NaN`：表示数学上未定义的结果，所有跟`NaN`交互的操作都返回`NaN`。
`is_nan`判断是否为`NaN`。


#### 数字运算

.......

#### 位运算

.......

#### 序列(Range)
Rust提供简洁方式生成连续数值、字符。
```rust
for i in 1..=5 {
    println!("{}",i);
}
1 2 3 4 5

for i in 'a'..='z' {
    println!("{}",i);
}

a b c .... z
```

#### 使用 As 完成类型转换

见后章 - 类型转换

#### 有理数和复数
因此有理数和复数并未包含在标准库中，常用社区高质量库·num·。

### 字符、布尔、单元类型

#### 字符类型

支持所有`Unicode`值，包括emoji表情等。
**Rust 的字符只能用 '' 来表示， "" 是留给字符串的**

#### 布尔(bool)

两个值：`true`和`false`，占1个字节。

#### 单元类型

唯一值：`()`，例如 `fn main()` main函数返回的就是单元类型`()`。
是一个零长度的元组，可以作为一个值用来占位，但是**完全不占用任何内存**。

### 语句和表达式

#### 语句


语句不返回任何值。


#### 表达式

表达式有返回值，如果不返回任何值会隐式返回`（）`。

函数也是表达式。

**调用宏** 也是表达式，如下：使用一个语句块表达式将值赋给 y 变量
```rust 
 let y = {
      let x = 3;
      x + 1
  };
```

表达式不能包含分号，例如以上`x + 1` 不能 写成 `x + 1;`，加上分号后就会变成**语句**，再也不会返回一个值。

`if` 语句块也是一个表达式，因此可以用于赋值，也可以直接返回。

```rust
 let y = if x % 2 == 1 {
      "odd"
  } else {
      "even"
  };
```

### 函数

#### 函数要点

1. 函数名和变量名使用**蛇形命名法(snake case)**，例如 `fn add_two() -> {}`。
2. 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可。
3. 每个**函数参数**都需要标注类型。

#### 函数参数

Rust 是静态类型语言，因此需要你为每一个函数参数都**标识出它的具体类型**。

#### 函数返回

函数的返回值就是函数体最后一条表达式的返回值。
也可以使用`return`提前返回。

##### 特殊返回类型

......

##### 永不返回的发散函数

使用 `!` 作函数返回类型。常用作会导致程序崩溃的函数。

```rust
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
fn forever() -> ! {
  loop {
    //...
  };
}
```

### 所有权和借用

使用 **所有权** 系统来代替 **GC** 引来的性能、内存占用及Stop the world等问题。

#### 所有权

内存管理的三种流派：
1. 垃圾回收GC。
2. 手动管理内存分配和释放。
3. 所有权管理内存。

**所有权管理内存** 只发生在**编译期**，程序运行时不会有任何性能损失。

#### 栈与堆

##### 栈 

**后进先出**，栈中所有数据必须占用已知**固定大小**的内存空间。

##### 堆

**未知数据大小**存储，放入数据时预先申请**一定大小**内存空间，返回一个表示该位置的**指针**。
返回的指针还是存入 **栈**。

##### 性能区别

**栈**内存分配快于**堆**。

##### 所有权与堆栈

**函数**的调用时，传递的参数将依次被压入**栈**中，当函数调用接触再移除。

#### 所有权原则

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)

##### 变量作用域
```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s不再有效
```

###### 动态String类型

字符串字面量类型字面值不可变。动态`String`类型分配到**堆**上，可以动态拉伸文本。
```rust
// 动态字符串
let s = String::from("hello");

// 字符换字面量
let s = "hello"
```

#### 变量绑定背后的数据交互

##### 转移所有权

``` rust
let x = 5;
let y = x;
```

以上代码不发生所有权转移，基本类型赋值，Rust会自动拷贝，**栈**上拷贝速度很快。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

以上代码存在所有权转移，因**String**类型是存在**堆上**的复杂类型。