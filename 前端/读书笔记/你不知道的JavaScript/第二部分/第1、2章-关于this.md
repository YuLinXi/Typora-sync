## 关于`this`


- `this`提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁易用。
- 关于this的误解：1.指向自身；2.它的作用域；
- `this`是在运行时进行绑定的，而不是在编写时。



## `this`全面解析

> 调用位置

- 分析`this`指向，首先得找到调用位置。
- 调用位置就是函数在代码中被调用的位置。
- 寻找调用位置最重要的是要`分析调用栈`。
- 调用栈可以想象成一个函数调用链。
- 使用`debugger`调试可以快速查找到真正调用位置。

> 绑定规则
- 找到调用位置后进行以下规则应用判断

>> 默认绑定
- 独立函数调用，但如果使用严格模式，该规则不生效。

>> 隐式绑定
- 函数调用位置是有上下文对象时，将函数调用中的this绑定到这个上下文对象。
- 对象属性引用链中只有最顶层会影响调用位置。
- 隐式丢失：被隐式绑定的函数会丢失绑定对象，它会应用默认绑定。

```
    function foo() {
        console.log(this.a)
    }

    var obj = { a:2, foo };
    var bar = obj.foo
    bar(); // undefined
```
>>> 解决隐式丢失
- 硬绑定：是显示绑定的一个变种。ES5中提供的内置的方式实现硬绑定`Funciton.prototype.bind`。`bind(...)`会返回一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数。
- 一些API提供的"上下文"参数。
  【补充】：`bind`另外一个好的功能是除了把第一个参数之外的其它参数都传递给下层函数（这种技术称为“部分应用”，也是“柯里化”的一种）。

```
    function foo(el) {
        console.log(el, this.id);
    }

    var obj = {
        id: 1
    }

    [1, 2, 3].forEach(foo, obj);

    // 1, 1
    // 2, 1
    // 3, 1
```
>> 显示绑定

- 使用函数的`call`和`apply`方法。
- 装箱：当call接收一个原始值（字符串、布尔、数字类型）当做this的绑定对象，这个原始值会被转换成它的对象形式（例：new String(..)）。

>> new绑定

- Javascript中`new`的实现机制和面向类的语言实现完全不同。
- 在传统面向对象语言中，"构造函数"是类中的一些特殊方法，使用new初始化类时会调用类中的构造函数。
- 在Javascript中，构造函数只是一些使用new操作符时被调用的函数，它们并不属于某个类，也不会实例化一个类。
- 可以说在Javascript中实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。
- 使用new来调用函数时会执行以下步骤：

```
    第一步：创建一个全新的对象。
    第二步：这个新对象会被执行[[ 原型 ]]链接。
    第三步：这个新对象会绑定到函数调用的this。
    第四步：如果函数没有返回其他对象，则自动返回这个新对象。
```

> 优先级

- 某个调用位置可以应用多条规则，规则的选择有优先级别。
- 优先级：new > 显式绑定(硬绑定) > 隐式绑定 > 默认绑定

#### 【总结】判断this
- 第一步：函数是否在new中调用？如果是的话this绑定的新创建的对象。
- 第二步：函数是否通过apply、call（显示绑定）或者硬绑定调用？如果是的话this指向的是指定的对象。
- 第三步：函数是否在某个上下文对象中调用（隐式调用）？如果是的话，this绑定的是这个上下文对象。
- 第四步：如果以上都不是的话，使用的是默认绑定。在严格模式下，this绑定的是undefined，否则绑定到全局对象。


> 绑定例外

- 在某些场景下this的绑定行为会出乎意料。

>> 被忽略的this

- 如何你把`null`、`undefined`作为this的绑定对象传入call、apply或者bind，实际会被应用默认绑定规则。

>> 更安全的this

- Object.create(null) 所创建的空对象和 `{}` 不一样，它不会创建Object.prototype的这个委托。

>> 间接引用

- 创建一个函数的`间接引用`时，调用这个函数会应用默认规则。

>> 软绑定

- 实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。

> this词法