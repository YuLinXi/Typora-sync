## 强制类型转换

- JavaScript 中的强制类型转换总是返回`标量基本类型值`如字 符串、数字和布尔值，不会返回对象和函数。
- 类型转换发生在静态类型语言的`编译阶段`，而强制类型转换则发生在动态类型语言的运行时(runtime)。

> 抽象值操作

- ToPrimitive操作有3种转化方式,`ToString`、`ToNumber`、`ToBoolean`。
- `ToPrimitive(input, PreferredType?)`

```
    如果PreferredType被设置为Number时
    1、如果输入的值已经是个原始值,则直接返回它.
    2、否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.
    3、否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.
    4、否则,抛出TypeError异常.
```

>> ToString

- `ToString`操作负责处理非字符串到字符串的强制类型转换。
- `极小`或`极大`的数字转换后采用指数形式表示。
- `JSON.stringify()`能转化的目标对象不包括`undefined`、`function`、`Symbol`和包含循环引用的的对象。JSON.stringify(..)在对象中遇到以上值时会自动忽略，在数组中则返回`null`。对包含循环引用的对象执行 JSON.stringify(..) 会出错。
- 如果对象有`toJSON()`方法，则`JSON.stringify()`调用时会首先调用该方法，并用它的返回值来进行序列化。
- `JSON.stringigy`第二个参数可以指定象序列化过程中哪些属性应该被处理、哪些应该被排除。第三个参数指定`space`。

>> ToNumber

- 其中`true`转换为`1`，`false`转换为`0`。`undefined`转换为`Na`，`null`转换为0。
- `ToNumber`操作对0开头的十六进制数并不按十六进制处理(而是按十进制处理）。

>> ToBoolean


> 显式强制类型转换

- `a.toString()`方法其中也涉及到了了隐式转换。
- `+`操作符可以显示转化为数字。
- `javascript`中构造函数`new F()`调用时可以不加括号。

>>  ~ 运算符

- `~`运算符只适用于`32`位整数。
- 早期的计算机科学和离散数学诠释，~返回`2`的补码。
- `~x`大致等同于 `-(x+1)`。
- `~~`字位截除操作符。将值截除为一个`32`位整数。
- `ES5`之后`parseInt()`默认转换为十进制数。

> 隐式强制类型转换

- 根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象(包括数组)，则首先对其调用 ToPrimitive 抽象操作(规范 9.1 节)，该抽象操作再调用 [[DefaultValue]](规范 8.12.8 节)，以数字作为上下文。

- `&&`和`||`运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。
- `==`允许在相等比较中进行强制类型转换，而`===`不允许。
- `==`和`===`在比较对象时的工作原理是一样的，两个对象指向同一个值时即视为相等，不发生强制类型转换。
- 字符串和数字之间的相等`==`比较时候，将其强制转换为`数字`进行比较。
- `null == undefined` 为 `true`。
- 对象和非对象之间的相等比较：(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果;(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。

- 抽象关系比较：分为两种情况。1、皆为字符串。2、其它部分。
    - 如果比较双方都是字符串，则按字母顺序来进行比较。   

- 根据规范`a <= b`被处理为`b < a`,然后将结果反转。