Javascript自有类型系统问题的`最终`解决方案，前端领域的`第二语言`

渐进式

## 类型安全

> 强类型

语言层面限制函数的实参类型必须形参类型相同，有更强的类型约束（不允许任何式类型转换）  
优势：
1. 更早的暴露问题
2. 代码更智能，编译更准确
3. 重构更牢靠
4. 减少不必要的类型判断

弱类型: 而弱语言几乎没有  

## 类型检查

静态类型：一个变量声明时它的类型就是明确的，它的类型声明过后不允许再修改  
动态类型：在运行阶段才能明确变量类型，而且变量的类型随时可以改变

## Typescript 

部分特性解释

> Object类型

泛指所有非`原始类型`，包含`对象`、`数组`、`函数`等  
使用`对象字面量语法`标记单纯的对象类型，`const a: {} = {}`; 一般使用`接口`去实现对象类型

> 数组类型  

配合`泛型`可以指定元素类型 

```
const arr: Array<number> = [1, 2, 3]
const arr: number[] = [1, 2, 3]
```

> 元祖类型 

明确元素类型和数量的类型

```
const tuple: [number, string] = [18, '11']
```

例如：`Object.entries`就是一个元祖类型

> 枚举类型 

可以给一组数值取上`别名`，且值在固定范围内  

枚举默认以数字方式从0开始累加，如果为`string`类型则需要明确声明枚举值 

枚举类型会入侵到运行时的代码，编译过后会出现在代码中，生成一个`双向键值对对象`即可以通过`键获取值`也可以通过`值获取键`，仅对`数字类型有效`

使用`const枚举`，如`const enums = {}`，可以避免`非直接`的对枚举成员访问和生成代码上的额外开销 

> 类型断言

JSX下不能使用`<number>`断言  
编译后忽略

> 接口 

抽象概念，约定对象结构，编译后忽略   

动态成员
```
interface Cache {
    [prop: string]: string
}
```

> 类 class 

在支持`ES6`类的基础上进行了扩展和完善

> 抽象类 

类似于`接口`，可以约束`类`的成员，不同在于`抽象类`包含具体实现

> 类型声明 

于第三方非`typescript`模块使用时，对参数进行类型声明，也可以安装对应的如`@types/lodash`的类型声明模块，否则可以使用`declare`进行声明