
## 内存管理  

内存：由可读写单元组成，表示一片可操作空间  
管理：人为去操作一片空间的申请、使用和释放  
内存管理：开发者主动申请空间、使用空间、释放空间  
管理流程：申请-使用-释放  

## JavaScript 垃圾回收 

JavaScript中内存管理是自动的  

> 垃圾包含  

对象不再被引用时  
对象不能从根上访问到时 

** 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

> JavaScript 可达对象 

可以访问到的对象就是可达对象（引用、作用域链）  

可达的标准就是从根（全局变量对象）出发是否能够被找到  

## GC定义与作用 

垃圾回收机制 

可以找到内存中的垃圾、并释放和回收空间  

> 常见GC算法： 

引用计数、标记清除、标记整理、分代回收

> 引用计数 

设置引用数，判断当前引用数是否为0

优点：

- 发现垃圾时立即回收  
- 最大限度减少程序暂停  

缺点：

- 原始的引用计数无法解决循环引用问题 
- 频繁更新引用计数会降低运行效率，时间开销大

> 标记清除 

1. 标记：从根结点出发遍历对象，对可达对象打上标记 
2. 清除：遍历所有对象清除没有标记的对象，同时将第一步中已标记对象的`标记清除`，等待`下一次GC回收`，把回收的空间放在`当前空闲列表`中去等待重新分配

优点：

- 解决对象循环引用  

缺点：

- 地址不连续，容易产生碎片化空间
- 不会立即回收垃圾对象

> 标记整理  

标记清除的增强算法，标记阶段一致，在`清除`阶会先执行整理当前地址空间，使其在地址上保持连续，再进行清除

## V8引擎 

V8采用及时编译，直接将源码翻译成机器码  
V8内存设限，64位不超过`1.5g`，32位不超过`800M`

> V8垃圾回收策略  

采用分代回收思想  
内存分为新生代、老生代  
针对不同对象采用不同算法

V8中常用的GC算法 

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

> V8内存分配  

V8内存空间一分为二，分为`老生代`、`新生代`

<h5>新生代回收</h5>  

小空间用于存储新生代对象（32M|16M）  
新生代指的是存活时间较短的对象  

1. 新生代内存分为二个等大小空间
2. 使用空间`From`，空闲空间为`To`
3. 活动对象存储于`From`空间  
4. 标记整理后将活动对象拷贝至`To`
5. `From`和`To`交换空间完成释放 

细节说明：

拷贝过程中可能出现晋升  
晋升就是将新生代对象移动至老生代 

晋升出现的条件：
1. 一轮GC还存活的新生代需要晋升  
2. `To`空间的使用率超过`25%`

<h5>老生代回收</h5>

64位`1.4G`，32位操作系统`700M`  
老生代指储存存活时间较长的对象：全局对象、闭包

主要采用：`标记清除`、`标记整理`、`增量标记`

1. 首先使用标记清除完成垃圾空间的回收
2. 当出现`晋升`时，触发标记整理进行空间优化
3. 采用增量标记进行效率优化

细节对比；

新生代区域垃圾回收使用空间换时间  
老生代区域垃圾回收不适合复制算法

## 代码优化

如何精准测试JavaScript性能  

采集大量执行样本进行数学统计和分析  
基于`Benchmark.js`的 https://jsperf.com/ 完成

> 慎用全局变量  

- 全局变量定规在`全局执行上下文`，是所有作用域链的顶端  
- 全局执行上下文一直存在于上下文执行栈，直到程序退出 

> 缓存全局变量  

例如:

```
const doc = document;
const btn = doc.getElementById('#id');
```

> 通过原型新增方法  

执行效率更高

> 避开闭包陷阱

> 避免属性访问方法使用  

- js不需要属性的访问方法，所有属性都是外部可见的
- 使用属性访问方法只会增加一层定义，没有访问的控制力

```
// 以下形式尽量避免

function Person() {
 this.age = 18;
 this.getAge = function() {
     return this.age;
 }
}
// 避免
const p1 = new Person();
const age = p1.getAge();

// 推荐直接访问成员属性
const age = p1.age;
```

> for循环优化

1. for循环条件体内缓存`数组长度` 
```
for (var i=0, len = arr.length; i < len; i++){}
```

2. 选择最优的循环方式

`Array.forEach`相对效率较高

> 文档碎片优化节点添加  

document.createDocumentFragment()

> 克隆优化节点操作 

Node.cloneNode()

> 直接量替换new Object