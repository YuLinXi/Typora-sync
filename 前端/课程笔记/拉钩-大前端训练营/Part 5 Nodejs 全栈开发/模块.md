# 模块 

## 模块化规范

Commonjs规范：同步，不适用于web浏览器  
AMD规范：异步
CMD规范：兼具Commonjs与AMD规范
ES Modules 规范：纳入标准

### Commonjs规范

CommonJS规范是一种**超集**，是语言层面上的规范，类似于`ECMAScript`。

对模块化实现的规定：模块引用、模块定义、模块标识


## 模块分类及加载流程

### 模块分类 

1. 内置模块：Node源码编译时写入到二进制文件中了。
2. 文件模块（自定义模块、第三方包）：代码运行时动态加载

### 加载流程

1. 路径分析：依据标记符确定模块位置
2. 文件定位：确定目标模块中具体的文件及文件类型
3. 编译执行：采用对应的方式完成文件的编译执行，返回可用`exports对象`。

#### 路径分析

基于 **标识符** 进行模块的查找，标记符分为两类：

1. 路径标识符
2. 非路径标识符：核心模块例如`fs`、`path`、`express`

#### 文件定位

例：导入时使用`require('m1')`语法

1. 当文件没有指定扩展名，Node会以 **.js -> .json -> .node** 的顺序去查找对应文件。
2. 把`m1`当做目录，并将该目录当做一个**包**进行处理。因此进而查找该目录下的`package.json`下的`main`属性查找目标文件。
3. main属性没有扩展名时依然按 **步骤1** 进行补充查找。
4. 补足后还不存在，则默认将`index`作为目标模块中的具体文件名称，并同样以**步骤1**的补足顺序进行查找。
5. 如果还没有，则按照`module.paths`模块路径数组，一层一层往上查找。
6. 抛出查找失败异常。

#### 编译执行

步骤：创建新对象，按路径载入，完成编译执行。

**不同类型文件编译方式不一样**

##### JS文件

1. 使用fs模块同步读入目标文件内容。
2. 对内容进行语法包装，生成可执行的JS函数。
3. 调用函数时传入`exports`、`module`、`require`等属性值。

##### JSON文件

1. 将读取到的内容通过`JSON.parse()`进行解析。
2. 将结果返回给`exports`对象。

### 缓存优先原则

1. 优先使用缓存，提高模块加载速度。
2. 当前模块不存在，则经理一次完整的加载流程。
3. 模块加载完成后，使用**路径作为索引进行缓存。**

## VM模块 

node内置模块。
创建独立运行的沙箱环境。
实现将`JS字符串代码块`执行的库。