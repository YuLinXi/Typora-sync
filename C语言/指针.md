指针
===

运算符&
---

- 取得变量的地址，同事也必须是一个明确的变量
- 地址的大小是否与int相同取决于编译器（64位或32位）
- `%p`输出地址
- `&`不能对没有地址的取地址

数组的地址
---

- 数组整体的地址等于数组第一个单元的地址

指针
---

- 就是保存地址的变量

#### 指针变量

- `*`表示指针，int `*p = &i`或`int* p=&i`，表示p是一个指针，指向变量`i`
- 变量的值是内存的地址
    - 普通变量的值是实际的值
    - 指针变量的值是具有实际值的变量的地址
- 指针变量只能以一个地址作为值

#### 访问地址上的变量

- `*`是一个单目运算符，用来访问指针的值所表示的地址上的变量
- 可以做右值也可以做左值
    - int k = *p
    - *p = k + 1
        
#### 左值之所以叫左值

- `a[0] = 2`，`*p = 3`
- 是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果
- 是特殊的值，所以叫做左值

#### 指针最常见的错误

- 定义了指针变量，还没有指向任何变量，就开始使用指针

指针与数组
---

#### 传入函数的数组成了什么

- 函数参数表中的数组实际上是一个指针
    - sizeof(a) == sizeof(int *)
    - 但是可以用数组的运算符`[]`进行运算，即`a[0] = 1`

#### 数组变量是特殊的指针

``` 
int a[2] = {1, 2, 3}
int *p = a;
```

- 数组变量本身表达地址
- `[]`运算符可以对数组做，也可以对指针做
    - `p[0] = 1`
- `*`运算符可以对指针做，也可以对数组做
    - `*a=1` 
- 数组变量是`const`的指针，所以不能被赋值
    - `int b[]` ----> `int * const b`
    
#### 指针与const

- 指针可以是`const`，指针指向的那个变量也可以是`const`

##### 指针是const

- 表示一旦得到了某个变量的地址，不能再指向其它变量
    - `int * const q = &i`；q是const
    - `&q = 26`；OK
    - `q++`；Error
    
##### 指针所指是const

- 表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）
    - `const int *p = &i`
    - `*p = 26`；Error
    - `i = 26`；Ok
    - `p = &j`；Ok

##### 表示方法

- `const int* p1 = &i`等价于`int const* p2 = &i`，表示指针所指是const;
- `int *const p3 = &i`，表示指针是const;

#### const数组

- `const int a[] = {1, 2, 3}`表示数组里的单元全是`const`
- 可以保护数组的值
- 