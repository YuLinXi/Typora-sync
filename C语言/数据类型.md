类型
---
##### 基本类型

- 整数：char、short、int、long、long long（C99）
- 浮点数：float、double、long double（99）
- 逻辑 ：bool（C99）
- 指针

##### 其它类型

- 自定义类型

##### 类型不同之处

- 表达书范围：chart < short < int < float < double
- 输出格式化：%d、%ld、%lf
- 内存：1字节[chart]到16字节[long double]；sizeof()可以判断
- 内存中表现形式：二进制数（补码）[int]、编码[float、double等]

整数
---

##### 类型

- chart：1字节（8比特）
- short：2字节
- int、long：取决于编辑器（CPU）
- long long：8字节

##### 内部表达

- 计算机内部一切都是二进制
- 1字节可以表达的数：0000000 —— 11111111 （0-255）
 
##### 补码

- 补码的意义：拿补码和原码可以家出一个溢出的“零”
- 表示二进制负数
- 补码范围：11111111 ~ 10000000 表示 -1 ~ -128

##### unsigned

- 标记标量表达纯二进制
- 用l或L表示long(long)
- 主要为了位移

##### 整数越界

- 整数是以纯二进制方式进行计算
- 11111111 + 1 -> 100000000 -> 0
- 01111111 + 1 -> 10000000 -> -128
- 10000000 -1 -> 01111111 -> 127

##### 输入输出

- 只有两种形式：int或long long
    - %d：int
    - %u：unsigned
    - %ld：long long
    - %lu：unsigned long long


- 八进制或十六进制
    - 八进制：%o
    - 十六进制：%x 、%X
    - 16进制适合表达二进制数据
    - 8进制的一位数据正好表达3位二进制
    
##### 选择整数类型

- 没有特殊需要，就选择int
    - 现在的CPU的字长旁边是32位或者64位，一次内存读写就是一个int，选择更短的类型不会更快，甚至可能更慢
    - 现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小
    
- unsigned与否只是输出的不同，内部计算是一样的


浮点
---

##### 类型


类型  | 字长 | 范围 | 有效数字
---|---|---|---
float | 32字节 | ±（1.20 * 10^-38 ~ 3.40 * 10^38）,0,±inf,nan | 7
double | 64字节 | ±（2.2 * 10^-308 ~ 1.79 * 10^308）,0,±inf,nan | 15

±inf：正负无穷  
nan：不是一个有效数字

##### 输入输出


类型   | scanf | printf
---|---|---
float  | %f    | %f,%e
double | %lf   | %f,%e

%e：输出科学计数法

小数点后n位
- printf("%.3f", -0.0049); -0.005
- printf("%.30f", -0.0049); -0.00489999
- printf("%.3f", -0.0049); -0.000
        
##### 浮点运算的精度

- 1.345f：float
- 1.345：double
- f1 ≠ f2
- fabs(f1-f2) < 1e^-12判断是否相等

##### 浮点数内部表达

- 浮点数计算内部是编码形式
- 浮点数在计算时是由专用的硬件部件实现的
- 计算double和float所有的部件是一样的

##### 选择浮点类型

- 如果没有特殊需要，只用double
- 现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不必float慢

字符
---

##### 类型

- char是一种整数，也是一种特殊的类型：字符。
    - 用单引号表示的字符字面量：'a', '1'
    - ''也是一个字符
    - printf和scanf里用%c来输入输出字符
- '1'的ASCLL编码是49，49 == '1'

##### 字符计算

- 一个字符加一个数字得到ASCII码表中的那个数之后的字符
- 两个字符的减，得到它们在表中的距离
- a + 'a' - 'A'小写a变成大写A
- A + 'a' - 'A'大写A变成小写a

##### 逃逸字符


字符 | 意义 | 字符 | 意义
---|---|---|---
\b | 回退一个 | \" | 双引号
\t | 到下一个表格位 | \' | 单引号
\n | 换行 | \\ | 反斜杠本身
\r | 回车

自动类型转换
---

- 当运算符的两边出现不一致的类型时，会自动转换成较大的类型
    - 大的意思：能表达的数的范围更大
    - char -> short -> int -> long -> long long 
    - int -> float > double
- 对于printf，任何小于int的类型会被转换成int; float会被转换成double
- scanf不会转换

强制类型转换
---

- 强制转换
    - 类型（值）
    - 注意这时候的安全性，晓得变量不总能表达大的量
- 只是从变量计算出一个新的类型的值，它不改变原变量的值和类型
- 强制类型转换的优先级高于四则运算

bool
---

- #include <stdbool.h>
- 编辑器不会返回true或者false，只会是0或1

逻辑运算
---

- !、&&、||
- 判断字符c是否是大写`c>='A' && c<='Z'`
- 优先级 ! > && > ||
    